# 常见编程概念

## 变量和可变性

### 变量

变量默认是不可改变的，而尽管变量默认是不可变的，你仍然可以在变量名前添加 `mut` 来使其可变。

### 常量

1. 常量是绑定到一个名称的不允许改变的值，且不允许对常量使用 `mut` ，也即常量**总是**不能改变。
2. 声明常量使用 `const` 关键字而不是 `let` ，并且 **必须** 注明值的类型。
3. 常量可以在任何作用域中声明，包括全局作用域。
4. 常量只能被设置为常量表达式，而不可以是其他任何只能在运行时计算出的值。

### 隐藏

1. 可以用相同变量名称来隐藏一个变量，以及重复使用 `let` 关键字来多次隐藏。
2. mut 与隐藏的另一个区别是，当再次使用 let 时，实际上创建了一个新变量，我们可以改变值的**类型**，并且复用这个名字。

## 数据类型

Rust 是 静态类型（statically typed）语言，也就是说在编译时就必须知道所有变量的类型。Rust对数据类型的标定方式是 **注解**，即 `var: type` 。

### 标量类型

- 整型

|长度|有符号|无符号|
|:---:|:---:|:---:|
|8-bit|i8|u8|
|16-bit|i16|u16|
|32-bit|i32|u32|
|64-bit|i64|u64|
|128-bit|i128|u128|
|arch|isize|usize|

在Rust中允许使用 _ 做为分隔符以方便读数，例如1_000，它的值与你指定的 1000 相同。

|数字字面值|例子|
|:---:|---:|
|Decimal (十进制)|98_222|
|Hex (十六进制)|0xff|
|Octal (八进制)|0o77|
|Binary (二进制)|0b1111_0000|
|Byte (单字节字符)(仅限于u8)|b'A'|

- 浮点型

Rust 的浮点数类型是 f32 和 f64。

- 数值运算
- 布尔型
- 字符类型
  Rust 的 char 类型的大小为四个字节(four bytes)，并代表了一个 Unicode 标量值（Unicode Scalar Value），这意味着它可以比 ASCII 表示更多内容。
- 复合类型
  - tuple(元组)
    - 元组是一个将多个其他类型的值组合进一个复合类型的主要方式。元组长度固定：一旦声明，其长度不会增大或缩小。我们使用包含在圆括号中的逗号分隔的值列表来创建一个元组。 `let tup: (i32, f64, u8) = (500, 6.4, 1);`
    - 元组的解构：`let (x, y, z) = tup;` 或者 `let x = tup.0;`
    - 元组的别名：`type T = (i32, f64); let tup: T = (600, 6.4);`
  - array(数组)
    - 与元组不同，数组中的每个元素的类型必须相同且Rust中的数组长度是固定的。我们将数组的值写成在方括号内，用逗号分隔： `let a: [i32; 5] = [1, 2, 3, 4, 5];` 或者 `let a = [3; 5];` ([3,3,3,3,3])
    - 访问数组的元素 `let first = a[0];`

## 函数

我们在Rust 中通过输入 fn 后面跟着函数名和一对圆括号来定义函数。大括号告诉编译器哪里是函数体的开始和结尾。

### 参数

我们可以定义为拥有 **参数**（parameters）的函数，参数是特殊变量，是函数签名的一部分。当函数拥有参数（形参）时，可以为这些参数提供具体的值（实参）。

在函数签名中，**必须** 声明每个参数的类型。这是 Rust 设计中一个经过慎重考虑的决定：要求在函数定义中提供类型注解，意味着编译器再也不需要你在代码的其他地方注明类型来指出你的意图。而且，在知道函数需要什么类型后，编译器就能够给出更有用的错误消息。

### 语句和表达式

函数体由一系列的语句和一个**可选的结尾表达式**构成。因为 Rust 是一门**基于表达式**（expression-based）的语言，这是一个需要理解的（不同于其他语言）重要区别。

- 语句：带分号的，不返回值。不能这样写： `let x = (let y = 6);` 。
- 表达式：不带分号，会计算出(返回)一个值。表达式可以是语句的一部分，语句 `let y = 6;` 中的 `6` 就是一个表达式。

函数调用是一个表达式。宏调用是一个表达式。用大括号创建的一个新的块作用域也是一个表达式，例如：

``` Rust
fn main() {
    let y = {
        let x = 3;
        x + 1
    };

    println!("The value of y is: {y}");
}
```

其中

``` Rust
{
    let x = 3;
    x + 1
}
```

是一个代码块，也是表达式，返回值 `4` ，这个值作为大括号外的 `let` 语句的一部分被绑定到 `y` 上。 `x + 1` 是一个表达式，返回 `4` ，相当于 `return 4;`。

### 具有返回值的函数

函数可以向调用它的代码返回值。我们并不对返回值命名，但要在箭头（->）后声明它的类型。在 Rust 中，函数的返回值等同于函数体最后一个表达式的值。使用 `return` 关键字和指定值，可从函数中提前返回；但大部分函数隐式地返回最后的表达式。

## 注释

在 Rust 里为代码写文档一般用 `///` ，同时，在 `///` 里，还能写 markdown 格式的文本(包括反引号包含的代码)。

## 控制流

### if 表达式

### 在 let 语句中使用 if

`let number = if condition { 5 } else { 6 };`

## 使用循环重复执行

### 使用 loop 重复执行代码

``` Rust
loop{
  // ...
}
```

### 从循环返回值

`break counter * 2;` break关键字返回值 `count * 2` 。

### 循环标签：在多个循环之间消除歧义

如果存在嵌套循环，`break` 和 `continue` 应用于此时最内层的循环。你可以选择在一个循环上指定一个 **循环标签**（loop label），然后将标签与 `break` 或 `continue` 一起使用，使这些关键字应用于已标记的循环而不是最内层的循环。下面是一个包含两个嵌套循环的示例

``` Rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1;
    }
    println!("End count = {count}");
}
```

外层循环有一个标签 counting_up，它将从 0 数到 2。没有标签的内部循环从 10 向下数到 9。第一个没有指定标签的 break 将只退出内层循环。break 'counting_up; 语句将退出外层循环。

### while 条件循环

``` Rust
while number != 0 {
    println!("{number}!");

    number -= 1;
}
```

### 使用 for 遍历集合

``` Rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```

``` Rust
fn main() {
    for number in (1..4).rev() { // rev()为反转range
        println!("{number}!");
    }
    println!("LIFTOFF!!!");
}
```

|2022年7月20日|
|---:|
